"""
Subtitle Data Model and Manager for ThinkSub2.
"""

from dataclasses import dataclass, field
from enum import Enum, auto
from typing import List, Optional
import uuid


class SegmentStatus(Enum):
    """Status of a subtitle segment."""

    DRAFT = auto()  # Generated by Live pass (unstable)
    FINAL = auto()  # Generated by VAD End pass (stable, word-aligned)


@dataclass
class Word:
    """Represents a single word with timing information."""

    start: float
    end: float
    text: str
    probability: float = 1.0  # Internal confidence, NOT for UI display


@dataclass
class SubtitleSegment:
    """
    Represents a subtitle segment with timing and word-level data.
    """

    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    start: float = 0.0
    end: float = 0.0
    text: str = ""
    words: List[Word] = field(default_factory=list)
    status: SegmentStatus = SegmentStatus.DRAFT
    is_hidden: bool = False

    def duration(self) -> float:
        """Returns duration in seconds."""
        return self.end - self.start

    def to_srt_timecode(self, seconds: float) -> str:
        """Convert seconds to SRT timecode format (HH:MM:SS,mmm)."""
        hours = int(seconds // 3600)
        minutes = int((seconds % 3600) // 60)
        secs = int(seconds % 60)
        millis = int((seconds % 1) * 1000)
        return f"{hours:02d}:{minutes:02d}:{secs:02d},{millis:03d}"

    def to_srt(self, index: int) -> str:
        """Format segment as SRT entry."""
        return (
            f"{index}\n"
            f"{self.to_srt_timecode(self.start)} --> {self.to_srt_timecode(self.end)}\n"
            f"{self.text}\n"
        )


class SubtitleManager:
    """
    Manages a list of subtitle segments.
    Handles updates: Replaces DRAFT segments with FINAL ones.
    """

    def __init__(self):
        self._segments: List[SubtitleSegment] = []
        from collections import deque

        self._undo_stack: deque[List[SubtitleSegment]] = deque(maxlen=10)
        self._redo_stack: deque[List[SubtitleSegment]] = deque(maxlen=10)

    @property
    def segments(self) -> List[SubtitleSegment]:
        return self._segments

    def _save_state(self):
        """Save current state for undo (deep copy)."""
        import copy

        self._undo_stack.append(copy.deepcopy(self._segments))
        self._redo_stack.clear()  # Clear redo on new action

    def add_segment(self, segment: SubtitleSegment, save_undo: bool = False):
        """Add a new segment."""
        if save_undo:
            self._save_state()
        self._segments.append(segment)
        self._segments.sort(key=lambda s: s.start)

    def undo(self):
        """Revert to previous state. Returns previous state or False if none."""
        if not self._undo_stack:
            return False
        import copy

        current = copy.deepcopy(self._segments)
        self._redo_stack.append(current)
        self._segments = self._undo_stack.pop()
        return current

    def redo(self):
        """Re-apply an undone state. Returns previous state or False if none."""
        if not self._redo_stack:
            return False
        import copy

        current = copy.deepcopy(self._segments)
        self._undo_stack.append(current)
        self._segments = self._redo_stack.pop()
        return current

    def update_segment(
        self,
        segment_id: str,
        resolve_collision: bool = False,
        close_small_gaps: bool = True,
        **kwargs,
    ):
        """Update segment attributes."""
        self._save_state()
        active_seg = None
        for seg in self._segments:
            if seg.id == segment_id:
                active_seg = seg
                for key, value in kwargs.items():
                    if hasattr(seg, key):
                        setattr(seg, key, value)
                break

        if resolve_collision and active_seg:
            self._resolve_collisions(active_seg, close_small_gaps=close_small_gaps)

    def _resolve_collisions(
        self, active_seg: SubtitleSegment, close_small_gaps: bool = True
    ):
        """Push neighboring segments to avoid overlap."""
        # Sort first to ensure order
        self._segments.sort(key=lambda s: s.start)

        try:
            idx = self._segments.index(active_seg)
        except ValueError:
            return

        # Check Next (Push forward)
        # Iterate forward to propagate push
        for i in range(idx + 1, len(self._segments)):
            curr = self._segments[i - 1]
            next_seg = self._segments[i]

            if curr.end > next_seg.start:
                duration = next_seg.duration()
                # Touching edges (no artificial gap)
                next_seg.start = curr.end
                next_seg.end = next_seg.start + duration
            else:
                break  # No overlap, stop propagating

        # Check Prev (Push backward)
        # Iterate backward
        for i in range(idx - 1, -1, -1):
            curr = self._segments[i + 1]
            prev_seg = self._segments[i]

            if curr.start < prev_seg.end:
                duration = prev_seg.duration()
                # Touching edges (no artificial gap)
                prev_seg.end = curr.start
                prev_seg.start = prev_seg.end - duration
            else:
                break

        if close_small_gaps:
            # Fill tiny gaps that commonly appear due to rounding/snap (editor looks "gapped")
            self._close_small_gaps(max_gap=0.12)

    def _close_small_gaps(self, max_gap: float = 0.12):
        """Close small positive gaps between adjacent segments.

        This only extends the previous segment's end to the next segment's start.
        It does not shift segments or create overlaps.
        """
        if max_gap <= 0:
            return

        self._segments.sort(key=lambda s: s.start)
        for i in range(len(self._segments) - 1):
            a = self._segments[i]
            b = self._segments[i + 1]
            gap = b.start - a.end
            if 0 < gap <= max_gap:
                a.end = b.start

    def get_segment(self, segment_id: str) -> Optional[SubtitleSegment]:
        """Get a segment by ID."""
        for seg in self._segments:
            if seg.id == segment_id:
                return seg
        return None

    def finalize_segment(self, segment_id: str, words: List[Word]):
        """
        Replace a DRAFT segment with FINAL data including word timestamps.
        This is called after VAD End re-inference.
        """
        for seg in self._segments:
            if seg.id == segment_id:
                seg.words = words
                seg.status = SegmentStatus.FINAL
                break

    def get_time_from_text_index(self, segment_id: str, text_index: int) -> float:
        """Estimate timestamp from text index using word alignments."""
        seg = self.get_segment(segment_id)
        if not seg:
            return 0.0

        # Fallback if no words
        if not seg.words:
            if len(seg.text) == 0:
                return seg.start
            ratio = min(1.0, max(0.0, text_index / len(seg.text)))
            return seg.start + (seg.end - seg.start) * ratio

        # Map text index to word
        current_len = 0

        for word in seg.words:
            word_len = len(word.text)

            # Check if cursor is in this word
            if text_index <= current_len + word_len:
                local_idx = max(0, text_index - current_len)

                # Linear interpolation within word
                duration = word.end - word.start
                ratio = local_idx / word_len if word_len > 0 else 0
                return word.start + (duration * ratio)

            current_len += word_len

        return seg.end

    def split_segment_by_text_index(
        self, segment_id: str, text_index: int
    ) -> tuple[Optional[str], Optional[SubtitleSegment], Optional[SubtitleSegment]]:
        """Split segment based on text cursor index (for editor split)."""
        seg = self.get_segment(segment_id)
        if not seg:
            return None, None, None

        # If no words info, estimate time linearly
        if not seg.words:
            if len(seg.text) == 0:
                return None, None, None
            ratio = text_index / len(seg.text)
            split_time = seg.start + (seg.end - seg.start) * ratio
            return self.split_segment(segment_id, split_time)

        # Map text index to word
        current_len = 0
        split_time = seg.start

        # Reconstruct exactly how text is built
        # We assume seg.text == "".join(w.text for w in seg.words).strip()
        # But wait, seg.text might have been edited manually!
        # If edited manually, word mapping is unreliable.
        # Check if text matches roughly?
        # If text length differs significantly, fall back to linear interpolation.

        reconstructed = "".join([w.text for w in seg.words]).strip()
        if abs(len(reconstructed) - len(seg.text)) > 5:  # Threshold
            # Text was edited heavily, use linear
            if len(seg.text) == 0:
                return None, None, None
            ratio = text_index / len(seg.text)
            split_time = seg.start + (seg.end - seg.start) * ratio
            return self.split_segment(segment_id, split_time)

        # Find split point using words
        # Note: words usually include leading spaces if coming from Whisper
        for word in seg.words:
            word_len = len(word.text)
            # If we stripped the segment text, we might need to account for offset?
            # For simplicity, assuming relatively aligned.

            if current_len + word_len >= text_index:
                # Cursor is within this word or at boundary
                local_idx = text_index - current_len

                # Split before word if cursor at start, after if at end
                if local_idx <= 0:
                    split_time = word.start
                elif local_idx >= word_len:
                    split_time = word.end
                else:
                    # In middle of word. Whisper doesn't give char-level.
                    # Split linearly within word duration
                    w_duration = word.end - word.start
                    w_ratio = local_idx / word_len
                    split_time = word.start + (w_duration * w_ratio)
                break

            current_len += word_len
            split_time = word.end

        return self.split_segment(segment_id, split_time)

    def split_segment(
        self, segment_id: str, split_time: float
    ) -> tuple[Optional[str], Optional[SubtitleSegment], Optional[SubtitleSegment]]:
        """
        Split a segment at the given time.
        Returns: (new_segment_id, original_segment_after_update, new_segment)
        """
        self._save_state()
        for i, seg in enumerate(self._segments):
            if seg.id == segment_id:
                if seg.start < split_time < seg.end:
                    # Smart Split using Words
                    current_words = seg.words
                    first_part_words = []
                    second_part_words = []

                    if current_words:
                        for word in current_words:
                            # Use center of word to decide ownership
                            word_center = (word.start + word.end) / 2

                            if word_center > split_time:
                                second_part_words.append(word)
                            else:
                                first_part_words.append(word)

                        # Reconstruct text from words
                        # Use "".join() because Whisper words typically include leading spaces.
                        first_text = "".join([w.text for w in first_part_words]).strip()
                        second_text = "".join(
                            [w.text for w in second_part_words]
                        ).strip()
                    else:
                        # Fallback: No word info (keep text in first, empty in second)
                        # Or user might prefer duplicate text? Let's keep first.
                        first_text = seg.text
                        second_text = ""

                    # Create new segment for the latter part
                    new_seg = SubtitleSegment(
                        start=split_time,
                        end=seg.end,
                        text=second_text,  # Smart split text
                        status=seg.status,
                        words=second_part_words,
                    )

                    # Update original segment
                    seg.end = split_time
                    seg.text = first_text
                    seg.words = first_part_words

                    # Insert new segment
                    self._segments.insert(i + 1, new_seg)
                    return new_seg.id, seg, new_seg
        return None, None, None

    def merge_segments(
        self, segment_ids: List[str]
    ) -> tuple[Optional[SubtitleSegment], List[str]]:
        """Merge multiple consecutive segments into one."""
        if len(segment_ids) < 2:
            return None, []

        self._save_state()
        # Find segments and ensure they are consecutive
        indices = []
        for seg_id in segment_ids:
            for i, seg in enumerate(self._segments):
                if seg.id == seg_id:
                    indices.append(i)
                    break

        if not indices:
            return None, []

        indices.sort()
        # Check if consecutive
        for i in range(len(indices) - 1):
            if indices[i + 1] - indices[i] != 1:
                return None, []  # Not consecutive

        # Merge
        first = self._segments[indices[0]]
        texts = [self._segments[i].text for i in indices]
        first.text = " ".join(texts)
        first.end = self._segments[indices[-1]].end
        first.status = SegmentStatus.DRAFT  # Mark as draft after merge

        # Remove merged segments (except first)
        removed_ids = []
        for i in reversed(indices[1:]):
            removed_ids.append(self._segments[i].id)
            del self._segments[i]

        # After merge, close any tiny gaps in neighbors
        self._close_small_gaps(max_gap=0.12)
        return first, removed_ids

    def delete_segments(self, segment_ids: List[str]) -> List[str]:
        """Delete specified segments."""
        self._save_state()
        removed = [s.id for s in self._segments if s.id in segment_ids]
        self._segments = [s for s in self._segments if s.id not in segment_ids]
        return removed

    def undo(self):
        """Undo last action. Returns previous segments or False."""
        if self._undo_stack:
            import copy

            self._redo_stack.append(copy.deepcopy(self._segments))
            prev = self._segments
            self._segments = self._undo_stack.pop()
            return prev
        return False

    def redo(self):
        """Redo last undone action. Returns previous segments or False."""
        if self._redo_stack:
            import copy

            self._undo_stack.append(copy.deepcopy(self._segments))
            prev = self._segments
            self._segments = self._redo_stack.pop()
            return prev
        return False

    def delete_drafts(self):
        """Delete all segments with status=DRAFT."""
        # Optimization: Check if we have any drafts first to avoid saving state unnecessarily
        if any(s.status == SegmentStatus.DRAFT for s in self._segments):
            self._save_state()
            self._segments = [
                s for s in self._segments if s.status != SegmentStatus.DRAFT
            ]

    def clear(self):
        """Clear all segments."""
        self._segments.clear()
        self._undo_stack.clear()
        self._redo_stack.clear()

    def export_srt(self) -> str:
        """Export all segments as SRT format."""
        lines = []
        for i, seg in enumerate(self._segments, start=1):
            lines.append(seg.to_srt(i))
        return "\n".join(lines)

    def export_metadata(self) -> List[dict]:
        """Export segments as metadata (for LoRA training, etc.)."""
        return [
            {
                "start": seg.start,
                "end": seg.end,
                "text": seg.text,
                "words": [
                    {"start": w.start, "end": w.end, "text": w.text} for w in seg.words
                ],
            }
            for seg in self._segments
        ]

    @staticmethod
    def parse_srt(content: str) -> List[SubtitleSegment]:
        """Parse SRT content into SubtitleSegments."""
        import re

        segments = []

        # Split by empty double newlines
        blocks = re.split(r"\n\s*\n", content.strip())

        for block in blocks:
            lines = block.strip().split("\n")
            if len(lines) >= 3:
                # Line 1: Index (skip)
                # Line 2: Timecode
                times = lines[1].split("-->")
                if len(times) != 2:
                    continue

                start_str = times[0].strip()
                end_str = times[1].strip()

                def parse_time(t_str):
                    # HH:MM:SS,mmm
                    parts = t_str.replace(",", ".").split(":")
                    if len(parts) == 3:
                        h, m, s = parts
                        return int(h) * 3600 + int(m) * 60 + float(s)
                    return 0.0

                start = parse_time(start_str)
                end = parse_time(end_str)

                # Line 3+: Text (preserve multiline)
                text = "\n".join(lines[2:]).strip()

                segments.append(
                    SubtitleSegment(
                        start=start,
                        end=end,
                        text=text,
                        status=SegmentStatus.FINAL,  # Imported files are treated as Final
                    )
                )
        return segments
